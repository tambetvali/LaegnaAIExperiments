# This is a simple command line client, which will pull the dependencies and run the model.
#   Remove model from configuration file if you do not want to pull it, i.e. while ollama or litellm,
#   accidentially.

# This whole interface is used only to update model_select.json, which automatically contains conf.
# of the single model you selected. You could install framework based on that. Other file,
# models_config.json, is simpler to edit manually as it won't be changed automatically.
# You can add your autogenerated list of models to models_config.json, and additional script
# running before this one could collect your avaiable models of your providers; litellm likely
# supports your provider: an OpenAI compatible AI system.

import json
import os
import curses # we use colorama if not in full-console mode

# Load models_config_data from models_config.json
with open('models_config.json', 'r') as f:
    models_config_data = json.load(f)

def transform_models_config(models_config_data):
    config_data = []
    for model in models_config_data.get("models", []):
        config_item = {
            "localname": model.get("localname"), # your own invented name for internal use
            "provider": model.get("provider"), # who is running the server
            # Internalprovider is the different Python wramework we use to access the same model.
            #   it can be ollama or litegpt while provider service is still ollama, whych can be accessed
            #   even directly as requests; TODO: consider implement raw access with requests as internalprovider.
            "internalprovider": model.get("internalprovider"),
            "model": model.get("model"), # model name in the AI service
            "host": model.get("host") # for example http://localhost:PORTNUMBER
        }
        config_data.append(config_item)
    return config_data

# Configuration data
config_data = transform_models_config(models_config_data)

def draw_menu(stdscr, selected_idx):
    height, width = stdscr.getmaxyx()
    
    for idx in range(len(config_data)):
        item = config_data[idx]
        name = item.get("localname", item["model"])
        
        # Formatting based on selection
        if idx == selected_idx:
            color_pair = curses.color_pair(1)
            prefix = "*"
        else:
            color_pair = curses.color_pair(2)
            prefix = " "
        
        text = prefix + f" {name} " + prefix
        stdscr.addstr(idx + 1, (width - len(text)) // 2, text, color_pair)

    # Clear the prompt line
    stdscr.addstr(height - 3, 0, " " * width)  
    # Display selected item information
    selected_item = config_data[selected_idx]
    info_text = f"M{selected_idx+1} selected: {config_data[selected_idx]['model']}"
    stdscr.addstr(height - 3, (width - len(info_text)) // 2, info_text, curses.color_pair(3))
    
    # Clear the input line
    stdscr.addstr(height - 2, 0, " " * width)  
    # Move cursor to the prompt line
    stdscr.move(height - 1, 0)

def main(stdscr):
    # Initialize color pairs
    curses.start_color()
    curses.init_pair(1, curses.COLOR_RED, curses.COLOR_BLACK)  # Selected item
    curses.init_pair(2, curses.COLOR_WHITE, curses.COLOR_BLACK)  # Unselected items
    curses.init_pair(3, curses.COLOR_RED,   curses.COLOR_BLACK)  # Selection info

    selected_idx = 0
    while True:
        draw_menu(stdscr, selected_idx)
        
        key = stdscr.getch()
        
        if key == curses.KEY_UP:
            if selected_idx > 0:
                selected_idx -= 1
        elif key == curses.KEY_DOWN:
            if selected_idx < len(config_data) - 1:
                selected_idx += 1

        # Handle model selection
        if key in [curses.KEY_ENTER, 10]:  # Enter or Return key pressed
            current_model = config_data[selected_idx]
            with open('model_select.json', 'w') as f:
                json.dump(current_model, f)
            return

if __name__ == "__main__":
    if os.path.exists('model_select.json'):
        # Check if a model is already selected
        with open('model_select.json', 'r') as f:
            current_model = json.load(f)
            if 'model' in current_model and current_model['model'] is not None:
                print("Model is already selected. Exiting.")
                exit(0)

    # If no model is selected, run the model selection menu
    curses.wrapper(main)

"""
### Explanation:

1. **curses Initialization**: The script initializes the `curses` library 
to handle terminal input and output.
2. **Color Pairing**: Two color pairs are defined using 
`curses.init_pair()`. One pair for selected items (red background, yellow 
text) and another for unselected items (white bold text).
3. **draw_menu Function**: This function draws the menu on the screen. It 
iterates over the configuration data, formats each item based on whether 
it is selected or not, and adds it to the screen.
4. **main Function**: This is the main loop of the script. It continuously 
redraws the menu and handles keyboard input (up arrow, down arrow, Enter 
key) to navigate and select an item.
"""